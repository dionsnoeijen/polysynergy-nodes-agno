import uuid
from textwrap import dedent
from typing import Any, cast, Literal

from agno.agent import Agent
from agno.db import BaseDb
from agno.models.base import Model
from agno.team import Team

from polysynergy_node_runner.setup_context.dock_property import dock_property, dock_select_values, dock_text_area, dock_dict
from polysynergy_node_runner.setup_context.node_decorator import node
from polysynergy_node_runner.setup_context.node_error import NodeError
from polysynergy_node_runner.setup_context.node_variable_settings import NodeVariableSettings
from polysynergy_node_runner.setup_context.path_settings import PathSettings
from polysynergy_node_runner.setup_context.service_node import ServiceNode

from polysynergy_nodes_agno.agno_agent.utils.extract_props_from_settings import extract_props_from_settings
from polysynergy_nodes_agno.agno_agent.utils.find_connected_members import find_connected_members
from polysynergy_nodes_agno.agno_agent.utils.find_connected_service import find_connected_service
from polysynergy_nodes_agno.agno_agent.utils.find_connected_settings import find_connected_settings
from polysynergy_nodes_agno.agno_agent.utils.find_connected_db_settings import find_connected_db_settings
from polysynergy_nodes_agno.agno_agent.utils.find_connected_tools import find_connected_tools
from polysynergy_nodes_agno.agno_agent.utils.find_connected_path_tools import find_connected_path_tools
from polysynergy_nodes_agno.agno_agent.utils.find_connected_guardrails import find_connected_guardrails
from polysynergy_nodes_agno.agno_agent.utils.has_connected_agent_or_team import has_connected_agent_or_team
from polysynergy_nodes_agno.agno_agent.utils.find_connected_prompt import find_connected_prompt
from polysynergy_nodes_agno.agno_agent.utils.send_chat_stream_event import send_chat_stream_event
from polysynergy_nodes_agno.agno_agent.utils.create_team_tool_hook import create_team_tool_hook
from polysynergy_nodes_agno.agno_agent.utils.build_tool_mapping import build_tool_mapping


@node(
    name="Agno Team",
    category="agno_agent",
    icon="agno.svg",
)
class AgnoTeam(ServiceNode):

    avatar: str = NodeVariableSettings(
        label="Avatar",
        dock=dock_property(metadata={"custom": "openai_avatar"}),
        metadata={"custom": "openai_avatar"},
    )

    debug_mode: bool = NodeVariableSettings(
        group="debug",
        dock=True,
        node=False,
        info="Enable debug logs for this agent."
    )

    debug_level: str = NodeVariableSettings(
        group="debug",
        node=False,
        dock=dock_property(select_values={"1": "1", "2": "2"}),
        info="Debug verbosity level: 1 = basic, 2 = detailed."
    )

    monitoring: bool = NodeVariableSettings(
        dock=True,
        info="If True, logs agent events to agno.com for monitoring purposes.",
        node=False
    )

    telemetry: bool = NodeVariableSettings(
        dock=True,
        info="If True, enables minimal telemetry for usage analytics and diagnostics.",
        node=False
    )

    store_member_responses: bool = NodeVariableSettings(
        dock=True,
        default=True,
        node=False,
        info="If True, stores member responses in the team run output (Agno v2).",
    )

    show_full_reasoning: bool = NodeVariableSettings(
        dock=True,
        default=False,
        info="Show the full reasoning process from reasoning models (o1, o3-mini, gpt-5-mini, DeepSeek-R1, etc.)",
        node=False
    )

    # INPUT

    model: Model | None = NodeVariableSettings(
        label="Model",
        has_in=True
    )

    db: BaseDb | None = NodeVariableSettings(
        label="Db",
        has_in=True,
        info="Storage backend for conversation history (e.g., DynamoDB, SQLite)"
    )

    agent_or_team: Agent | Team | None = NodeVariableSettings(
        has_in=True,
        info="Specify whether this tool is for an agent or a team.",
    )

    prompt: str = NodeVariableSettings(
        label="Prompt",
        dock=True,
        has_in=True,
        info="The prompt or task description for the agent to execute."
    )

    guardrails: Any | list | None = NodeVariableSettings(
        label="Guardrails",
        dock=True,
        has_in=True,
        info="List of guardrails to validate team inputs (PII detection, prompt injection, moderation, etc.)"
    )

    team_name: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="The name of the team. If not set, it will be autogenerated.",
    )

    user_id: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="The ID of the user interacting with this team. If not set, it will be autogenerated.",
    )

    session_id: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="Unique session ID to group messages. Leave empty to auto-generate."
    )

    session_name: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="Optional name for the session, useful for debugging or display."
    )

    user: dict | None = NodeVariableSettings(
        label="User Context",
        dock=True,
        has_in=True,
        info="Full user context (name, email, role, etc.) - automatically injected into team instructions"
    )

    description: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="A brief description of the team.",
    )

    instructions: str | None = NodeVariableSettings(
        dock=dock_text_area(rich=True),
        has_in=True,
        info="A list of instructions for the team. If not set, it will be autogenerated.",
    )

    expected_output: str | None = NodeVariableSettings(
        group="messaging",
        dock=dock_text_area(),
        has_in=True,
        info="The expected output from the team, included in the prompt."
    )

    # Removed success_criteria as per Agno v2 - no longer supported

    settings: dict = NodeVariableSettings(
        dock=dock_dict(
            enabled=False,
            key_label="Setting name",
            value_label="Setting value",
            in_switch=False,
            out_switch=False,
            type_field=False,
            in_switch_default=True,
            out_switch_default=False,
            info="Custom settings for the agent. Can include tool configurations or other parameters."
        ),
        info="Additional settings for the agent, such as tool configurations or custom parameters.",
        has_in=True,
        default=[
            {
                "handle": "context",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_context.TeamSettingsContext",
                "value": "polysynergy_nodes_agno.agent.team_settings_context.TeamSettingsContext",
            },
            {
                "handle": "history",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_history.TeamSettingsHistory",
                "value": "polysynergy_nodes_agno.agent.team_settings_history.TeamSettingsHistory",
            },
            {
                "handle": "knowledge",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_knowledge.TeamSettingsKnowledge",
                "value": "polysynergy_nodes_agno.agent.team_settings_knowledge.TeamSettingsKnowledge",
            },
            {
                "handle": "reasoning",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_reasoning.TeamSettingsReasoning",
                "value": "polysynergy_nodes_agno.agent.team_settings_reasoning.TeamSettingsReasoning",
            },
            {
                "handle": "session",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_session.TeamSettingsSession",
                "value": "polysynergy_nodes_agno.agent.team_settings_session.TeamSettingsSession",
            },
            {
                "handle": "storage",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_storage.TeamSettingsStorage",
                "value": "polysynergy_nodes_agno.agent.team_settings_storage.TeamSettingsStorage",
            },
            {
                "handle": "streaming",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_streaming.TeamSettingsStreaming",
                "value": "polysynergy_nodes_agno.agent.team_settings_streaming.TeamSettingsStreaming",
            },
            {
                "handle": "structured_output",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_structured_output.TeamSettingsStructuredOutput",
                "value": "polysynergy_nodes_agno.agent.team_settings_structured_output.TeamSettingsStructuredOutput",
            },
            {
                "handle": "system_message",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_system_message.TeamSettingsSystemMessage",
                "value": "polysynergy_nodes_agno.agent.team_settings_system_message.TeamSettingsSystemMessage",
            },
            {
                "handle": "team_history",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_team_history.TeamSettingsTeamHistory",
                "value": "polysynergy_nodes_agno.agent.team_settings_team_history.TeamSettingsTeamHistory",
            },
            {
                "handle": "team_tools",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_team_tools.TeamSettingsTeamTools",
                "value": "polysynergy_nodes_agno.agent.team_settings_team_tools.TeamSettingsTeamTools",
            },
            {
                "handle": "tools",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.team_settings_tools.TeamSettingsTools",
                "value": "polysynergy_nodes_agno.agent.team_settings_tools.TeamSettingsTools",
            },
        ]
    )

    instance: Team = NodeVariableSettings(
        label="Instance",
        info="Instance of this node for use in the agent.",
        has_in=True,
        has_out=True,
        type="polysynergy_nodes_agno.agent.agno_team.AgnoTeam"
    )

    # Team behavior controls (replacing deprecated 'mode')
    respond_directly: bool = NodeVariableSettings(
        dock=True,
        default=False,
        info="If True, the team leader won't process responses from members and will return them directly."
    )

    delegate_task_to_all_members: bool = NodeVariableSettings(
        dock=True,
        default=False,
        info="If True, delegate tasks to all members simultaneously (parallel execution in async mode)."
    )

    determine_input_for_members: bool = NodeVariableSettings(
        dock=True,
        default=True,
        info="If True, team leader synthesizes input for members. If False, sends run input directly."
    )

    tools: bool = NodeVariableSettings(
        has_out=True,
        out_type_override="agno.team.team.Team",
        info="List of tools available to the model. Tools can be functions, Toolkits, or dict definitions.",
    )

    path_tools: str | None = NodeVariableSettings(
        has_out=True,
        out_type_override="polysynergy_nodes_agno.agno_native_tools.agno_path_tool.AgnoPathTool",
        info="Path tools (flow tools) that execute subflows and return results to the agent.",
    )

    # METRICS

    metrics: dict = NodeVariableSettings(
        group="metrics",
        dock=False,
        has_out=True,
        info="Metrics collected during agent execution, such as response time or token usage."
    )

    # OUTPUT

    members: bool = NodeVariableSettings(
        out_type_override="agno.team.team.Team,agno.agent.agent.Agent",
        has_out=True,
    )

    true_path: bool | str = PathSettings("Answer", info="This is the path for successful execution.")
    false_path: bool | str | dict = PathSettings("Error", info="This is the path for errors during execution.")

    async def _setup(self):
        model = await find_connected_service(self, "model", Model)
        db = await find_connected_service(self, "db", BaseDb)
        storage_settings = find_connected_db_settings(self, True)

        settings = await find_connected_settings(self)
        tool_info_list = await find_connected_tools(self)
        path_tools = find_connected_path_tools(self)
        print(f"ðŸ” [TEAM {self.handle}] Found {len(path_tools)} path tools")
        for i, pt in enumerate(path_tools):
            print(f"   {i+1}. {getattr(pt, 'name', 'UNKNOWN NAME')} (type: {type(pt).__name__})")
        guardrails = find_connected_guardrails(self)
        member_info_list = await find_connected_members(self)

        raw_level = self.debug_level or "1"  # default naar "1" als None of lege string
        debug_level = cast(Literal[1, 2], int(raw_level))

        if model is None:
            raise Exception("No model connected. Please connect a model to the node.")

        return model, db, storage_settings, settings, debug_level, tool_info_list, path_tools, guardrails, member_info_list

    async def _create_team(self):
        (model,
         db,
         storage_settings,
         settings,
         debug_level,
         tool_info_list,
         path_tools,
         guardrails,
         member_info_list
         ) = await self._setup()
        props = extract_props_from_settings(settings)
        props.update(storage_settings)

        # Use frontend node ID as team_id for consistency with chat history
        self.map_member_id_to_node_id = {}

        # Handle team members
        member_instances = []
        for item in member_info_list or []:
            member = item['member']
            member_instances.append(member)
            node_id = item['node_id']
            member_id = getattr(member, "id", None)
            if member_id and node_id:
               self.map_member_id_to_node_id[member_id] = node_id

        # Build tool instances and mapping using utility
        tool_instances, function_name_to_node_id, mcp_toolkits = await build_tool_mapping(tool_info_list, path_tools)

        # Create tool hook using utility
        tool_hook = create_team_tool_hook(self.context, function_name_to_node_id, mcp_toolkits)

        # Check for connected prompt node - prompt overrides manual settings
        prompt_data = find_connected_prompt(self)
        final_user_id = self.user_id
        final_session_id = self.session_id
        final_session_name = self.session_name
        final_user_context = None

        if prompt_data:
            final_user_id = prompt_data['user_id']
            final_session_id = prompt_data['session_id']
            final_user_context = prompt_data.get('user_context')
            print(f'TEAM PROMPT OVERRIDE: user_id={final_user_id}, session_id={final_session_id}, session_name={final_session_name}')
            if final_user_context:
                print(f"DEBUG: Got user_context from prompt: {final_user_context}")
        else:
            print(f'TEAM MANUAL SETTINGS: user_id={final_user_id}, session_id={final_session_id}, session_name={final_session_name}')

        # Fall back to manual user setting if no prompt context
        if not final_user_context and self.user:
            final_user_context = self.user

        # Generate defaults if needed for DB history to work
        if db and not final_session_id:
            final_session_id = str(uuid.uuid4())
            print(f'TEAM GENERATED SESSION ID: {final_session_id}')
        if db and not final_user_id:
            final_user_id = "default_user"
            print(f'TEAM USING DEFAULT USER ID: {final_user_id}')

        # Enhance instructions with user context if available
        user_context_text = ""
        if final_user_context:
            user_name = final_user_context.get('name', 'Unknown User')
            user_email = final_user_context.get('email', '')
            user_role = final_user_context.get('role', '')

            user_context_text = f"\n\nYou are currently assisting: {user_name}"
            if user_email:
                user_context_text += f" ({user_email})"
            if user_role:
                user_context_text += f"\nTheir role: {user_role}"
            user_context_text += "\n"
            print(f"Enhanced team instructions with user context for: {user_name}")

        # Combine instructions with user context
        final_instructions = None
        if self.instructions:
            final_instructions = dedent(self.instructions) + user_context_text
        elif user_context_text:
            final_instructions = user_context_text

        print('DB', db, storage_settings)

        self.instance = Team(
            id=self.id,
            name=self.team_name,
            members=member_instances or [],
            tools=tool_instances or [],
            db=db,
            model=model,
            user_id=final_user_id,
            session_id=final_session_id,
            instructions=final_instructions,
            description=dedent(self.description) if self.description else None,
            expected_output=dedent(self.expected_output) if self.expected_output else None,
            respond_directly=self.respond_directly,
            delegate_task_to_all_members=self.delegate_task_to_all_members,
            determine_input_for_members=self.determine_input_for_members,
            store_member_responses=self.store_member_responses,
            debug_mode=self.debug_mode,
            debug_level=debug_level,
            telemetry=self.telemetry,
            tool_hooks=[tool_hook],
            pre_hooks=guardrails if guardrails else [],
            events_to_skip=[],
            stream=True,
            **props
        )

    async def provide_instance(self) -> Team:
        await self._create_team()
        return self.instance

    async def execute(self):
        if has_connected_agent_or_team(self):
            print("Team is connected to another team/agent - skipping execution")
            return

        await self._create_team()
        
        if not self.prompt:
            print("No prompt provided")
            self.false_path = "No prompt provided for team execution"
            return
            
        self.map_member_id_to_node_id[self.instance.id] = self.id

        print(f"About to run team with prompt: {self.prompt[:100]}...")

        try:
            # In Agno v2, arun returns AsyncIterator[TeamRunOutputEvent] when stream=True
            stream = self.instance.arun(
                self.prompt,
                stream=True,
                stream_intermediate_steps=True,
                show_full_reasoning=self.show_full_reasoning
            )

            async def _collect_response(event_stream):
                final_response = None
                accumulated_content = []
                event_count = 0
                member_responses = {}

                async for event in event_stream:
                    event_count += 1

                    # Get event type (v2 naming)
                    event_type = getattr(event, 'event', None) or getattr(event, 'type', None)

                    # Determine node_id for the event
                    agent_id = getattr(event, "agent_id", None)
                    team_id = getattr(event, "team_id", None)

                    # Map to correct node for team members
                    if event_type in [
                        "RunContent",
                        "TeamRunContent",
                        "RunCompleted",
                        "TeamRunCompleted",
                        "RunStarted",
                        "TeamRunStarted",
                        "ToolCallStarted",
                        "ToolCallCompleted",
                        "ReasoningContent",  # Reasoning model thinking
                        "RunReasoningContent",  # Run-specific reasoning
                        "TeamRunReasoningContent",  # Team reasoning
                        "RunResponseContent",  # Backward compat
                        "TeamRunResponseContent",  # Backward compat
                        "RunResponse",  # Backward compat
                        "TeamRunResponse"  # Backward compat
                    ]:
                        node_id = (self.map_member_id_to_node_id.get(agent_id)
                                  or self.map_member_id_to_node_id.get(team_id)
                                  or self.id)
                    else:
                        node_id = None

                    # Determine if this is a member or leader event
                    is_member_agent = agent_id in self.map_member_id_to_node_id
                    agent_role = "member" if is_member_agent else "leader"
                    parent_team_id = self.id if is_member_agent else None

                    # Get member index if available
                    member_index = None
                    if is_member_agent and hasattr(self, 'team_members'):
                        try:
                            member_ids = list(self.map_member_id_to_node_id.keys())
                            member_index = member_ids.index(agent_id)
                        except (ValueError, AttributeError):
                            member_index = None

                    # Send events to UI
                    send_chat_stream_event(
                        flow_id=self.context.node_setup_version_id,
                        run_id=self.context.run_id,
                        node_id=node_id,
                        event=event,
                        agent_role=agent_role,
                        is_member_agent=is_member_agent,
                        parent_team_id=parent_team_id,
                        member_index=member_index
                    )

                    # Collect member responses if enabled
                    if self.store_member_responses and hasattr(event, 'content'):
                        if agent_id or team_id:
                            member_id = agent_id or team_id
                            if member_id not in member_responses:
                                member_responses[member_id] = []
                            member_responses[member_id].append(event.content)

                    # Store FINAL response events (not intermediate content)
                    if event_type in ['TeamRunResponse', 'TeamRunCompleted', 'RunResponse', 'RunCompleted']:
                        if hasattr(event, 'run_response'):
                            final_response = event.run_response

                    # Accumulate streaming content as fallback (for team leader content)
                    if hasattr(event, 'content') and event_type in ['TeamRunContent', 'RunContent']:
                        # Only accumulate if it's the team leader (not a member)
                        if not is_member_agent:
                            accumulated_content.append(event.content)

                # Use final response or accumulated content
                if final_response is None and accumulated_content:
                    # Join all content pieces
                    combined_content = ''.join(str(c) for c in accumulated_content)
                    # Create a simple response object
                    class SimpleResponse:
                        def __init__(self, content):
                            self.content = content
                    final_response = SimpleResponse(combined_content)

                return final_response, member_responses

            response, member_responses = await _collect_response(stream)

            # Persist member responses if enabled
            if self.store_member_responses and member_responses:
                storage = self.context.storage
                flow_id = self.context.node_setup_version_id
                run_id = self.context.run_id

                for member_id, content_parts in member_responses.items():
                    node_id = self.map_member_id_to_node_id.get(member_id)
                    if not node_id or node_id == self.id:
                        continue
                    
                    # Filter out None values before joining
                    valid_content_parts = [str(part) if part is not None else "" for part in content_parts]
                    final_text = "".join(valid_content_parts)

                    # Get order if available
                    try:
                        order = next(
                            x["order"] for x in self.context.execution_flow["nodes_order"]
                            if x["id"] == node_id
                        )
                    except (StopIteration, KeyError):
                        order = None

                    # Store member response
                    storage.set_node_variable_value(
                        flow_id=flow_id,
                        run_id=run_id,
                        node_id=node_id,
                        true_text=final_text,
                        order=order,
                        stage=self.context.stage,
                        sub_stage=self.context.sub_stage,
                    )

            # Extract content from the final response
            if hasattr(response, 'content'):
                self.true_path = response.content
            else:
                print(f"Response has no content attribute, using str: {str(response)}")
                self.true_path = str(response) if response else "Team execution completed"
            
            # Store metrics if available
            if hasattr(response, 'metrics'):
                self.metrics = response.metrics

        except Exception as e:
            self.false_path = NodeError.format(e, True)
            return
