import asyncio
import inspect
import uuid
from textwrap import dedent
from typing import Literal, cast, Callable

from agno.agent import Agent
from agno.models.base import Model
from agno.team import Team
from polysynergy_node_runner.execution_context.send_flow_event import send_flow_event

from polysynergy_node_runner.setup_context.dock_property import dock_text_area, dock_property, dock_dict
from polysynergy_node_runner.setup_context.node_decorator import node
from polysynergy_node_runner.setup_context.node_error import NodeError
from polysynergy_node_runner.setup_context.node_variable_settings import NodeVariableSettings
from polysynergy_node_runner.setup_context.path_settings import PathSettings
from polysynergy_node_runner.setup_context.service_node import ServiceNode

from polysynergy_nodes_agno.agent.utils.extract_props_from_settings import extract_props_from_settings
from polysynergy_nodes_agno.agent.utils.find_connected_model import find_connected_model
from polysynergy_nodes_agno.agent.utils.find_connected_path_tools import find_connected_path_tools
from polysynergy_nodes_agno.agent.utils.find_connected_settings import find_connected_settings
from polysynergy_nodes_agno.agent.utils.find_connected_tools import find_connected_tools
from polysynergy_nodes_agno.agent.utils.has_connected_agent_or_team import has_connected_agent_or_team


@node(
    name="Agno Agent",
    category="agno",
    icon="agno.svg",
)
class AgnoAgent(ServiceNode):

    avatar: str = NodeVariableSettings(
        label="Avatar",
        dock=dock_property(metadata={"custom": "openai_avatar"}),
        metadata={"custom": "openai_avatar"},
    )

    model: Model | None = NodeVariableSettings(
        label="Model",
        has_in=True
    )

    debug_mode: bool = NodeVariableSettings(
        dock=True,
        node=False,
        info="Enable debug logs for this agent."
    )

    debug_level: str = NodeVariableSettings(
        node=False,
        dock=dock_property(select_values={"1": "1", "2": "2"}),
        info="Debug verbosity level: 1 = basic, 2 = detailed."
    )

    monitoring: bool = NodeVariableSettings(
        dock=True,
        info="If True, logs agent events to agno.com for monitoring purposes.",
        node=False
    )

    telemetry: bool = NodeVariableSettings(
        dock=True,
        info="If True, enables minimal telemetry for usage analytics and diagnostics.",
        node=False
    )

    # INPUT

    agent_or_team: Agent | Team | None = NodeVariableSettings(
        has_in=True,
        info="Specify whether this tool is for an agent or a team.",
    )

    prompt: str = NodeVariableSettings(
        label="Prompt",
        dock=True,
        has_in=True,
        info="The prompt or task description for the agent to execute."
    )

    agent_name: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="The name of the agent, visible in the chat.",
    )

    agent_id: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="Unique identifier for this agent. Autogenerated if left blank."
    )

    user_id: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="Default user ID to associate with this agent during runs."
    )

    introduction: str | None = NodeVariableSettings(
        dock=True,
        has_in=True,
        info="Optional introduction added to the message history when the agent starts."
    )

    description: str | None = NodeVariableSettings(
        dock=dock_text_area(rich=True),
        has_in=True,
        info="A description of the agent, added to the start of the system message."
    )

    instructions: str | None = NodeVariableSettings(
        dock=dock_text_area(rich=True),
        has_in=True,
        info="Instructions for the agent. Can be a string, list, or callable."
    )

    goal: str | None = NodeVariableSettings(
        has_in=True,
        dock=dock_text_area(rich=True),
        info="The goal of the task, used in the system prompt."
    )

    expected_output: str | None = NodeVariableSettings(
        dock=dock_text_area(),
        has_in=True,
        info="The expected output from the agent, included in the prompt."
    )

    retries: int = NodeVariableSettings(
        group="response",
        dock=True,
        default=0,
        info="Number of times to retry the agent if an error occurs.",
        node=False
    )

    delay_between_retries: int = NodeVariableSettings(
        group="response",
        dock=True,
        info="Time in seconds to wait between retries.",
        default=1,
        node=False
    )

    exponential_backoff: bool = NodeVariableSettings(
        group="response",
        dock=True,
        info="If true, the delay between retries will double after each attempt.",
        node=False
    )

    # SETTINGS

    settings: dict = NodeVariableSettings(
        dock=dock_dict(
            enabled=False,
            key_label="Setting name",
            value_label="Setting value",
            in_switch=False,
            out_switch=False,
            type_field=False,
            in_switch_default=True,
            out_switch_default=False,
            info="Custom settings for the agent. Can include tool configurations or other parameters."
        ),
        info="Additional settings for the agent, such as tool configurations or custom parameters.",
        has_in=True,
        default=[
            {
                "handle": "context",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_context.AgentSettingsContext",
                "value": "polysynergy_nodes_agno.agent.agent_settings_context.AgentSettingsContext",
            },
            {
                "handle": "history",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_history.AgentSettingsHistory",
                "value": "polysynergy_nodes_agno.agent.agent_settings_history.AgentSettingsHistory",
            },
            {
                "handle": "knowledge",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_knowledge.AgentSettingsKnowledge",
                "value": "polysynergy_nodes_agno.agent.agent_settings_knowledge.AgentSettingsKnowledge",
            },
            {
                "handle": "memory",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_memory.AgentSettingsMemory",
                "value": "polysynergy_nodes_agno.agent.agent_settings_memory.AgentSettingsMemory",
            },
            {
                "handle": "messaging",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_messaging.AgentSettingsMessaging",
                "value": "polysynergy_nodes_agno.agent.agent_settings_messaging.AgentSettingsMessaging",
            },
            {
                "handle": "reasoning",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_reasoning.AgentSettingsReasoning",
                "value": "polysynergy_nodes_agno.agent.agent_settings_reasoning.AgentSettingsReasoning",
            },
            {
                "handle": "response_model",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_response_model.AgentSettingsResponseModel",
                "value": "polysynergy_nodes_agno.agent.agent_settings_response_model.AgentSettingsResponseModel",
            },
            {
                "handle": "session",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_session.AgentSettingsSession",
                "value": "polysynergy_nodes_agno.agent.agent_settings_session.AgentSettingsSession",
            },
            {
                "handle": "storage",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_storage.AgentSettingsStorage",
                "value": "polysynergy_nodes_agno.agent.agent_settings_storage.AgentSettingsStorage",
            },
            {
                "handle": "streaming",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_streaming.AgentSettingsStreaming",
                "value": "polysynergy_nodes_agno.agent.agent_settings_streaming.AgentSettingsStreaming",
            },
            {
                "handle": "team",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_team.AgentSettingsTeam",
                "value": "polysynergy_nodes_agno.agent.agent_settings_team.AgentSettingsTeam",
            },
            {
                "handle": "tools",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_tools.AgentSettingsTools",
                "value": "polysynergy_nodes_agno.agent.agent_settings_tools.AgentSettingsTools",
            },
            {
                "handle": "workflow",
                "has_in": True,
                "has_out": False,
                "published": False,
                "type": "polysynergy_nodes_agno.agent.agent_settings_workflow.AgentSettingsWorkflow",
                "value": "polysynergy_nodes_agno.agent.agent_settings_workflow.AgentSettingsWorkflow",
            }
        ]
    )

    instance: Agent = NodeVariableSettings(
        label="Agent Instance",
        info="Instance of the agent created by this node.",
        has_in=True,
        has_out=True,
        type="polysynergy_nodes_agno.agent.agno_agent.AgnoAgent"
    )

    # OUTGOING

    tools: bool = NodeVariableSettings(
        has_out=True,
        out_type_override="agno.agent.agent.Agent",
        info="List of tools available to the model. Tools can be functions, Toolkits, or dict definitions.",
    )

    path_tools: str | None = NodeVariableSettings(
        label="Flow Tools",
        has_out=True,
        default=[],
        info="Flow tools that execute subflows as agent tools."
    )

    # METRICS

    metrics: dict = NodeVariableSettings(
        dock=False,
        has_out=True,
        info="Metrics collected during agent execution, such as response time or token usage."
    )

    # OUTPUT

    true_path: bool | str = PathSettings("Answer", info="This is the path for successful execution.")
    false_path: bool | str | dict = PathSettings("Error", info="This is the path for errors during execution.")

    async def _setup(self):
        model = find_connected_model(self)

        settings = find_connected_settings(self)
        tool_info_list = find_connected_tools(self)
        path_tools = find_connected_path_tools(self)

        raw_level = self.debug_level or "1"  # default naar "1" als None of lege string
        debug_level = cast(Literal[1, 2], int(raw_level))
        if model is None:
            raise Exception("No model connected. Please connect a model to the node.")

        return model, settings, tool_info_list, path_tools, debug_level

    async def _create_agent(self):
        model, settings, tool_info_list, path_tools, debug_level = await self._setup()
        props = extract_props_from_settings(settings)
        self.agent_id = self.agent_id or str(uuid.uuid4())

        tool_instances = []
        function_name_to_node_id = {}

        # Add regular tools
        for item in tool_info_list:
            maybe_tool = item["tool"]
            toolkit = await maybe_tool if inspect.iscoroutine(maybe_tool) else maybe_tool
            tool_instances.append(toolkit)

            if hasattr(toolkit, "tools"):
                for tool in toolkit.tools:
                    fn_name = (
                        getattr(tool, "name", None)
                        or getattr(getattr(tool, "fn", None), "__name__", None)
                        or getattr(tool, "__name__", None)
                    )
                    if fn_name:
                        function_name_to_node_id[fn_name] = item["node_id"]

        # Add path tools (flow tools)
        for path_tool in path_tools or []:
            tool_instances.append(path_tool)
            # Path tools are Agno Function objects with name attribute
            if hasattr(path_tool, 'name'):
                function_name_to_node_id[path_tool.name] = f"path_tool_{path_tool.name}"

        print('TOOLS MAPPING', function_name_to_node_id)

        async def tool_hook(function_name: str, function_call: Callable, arguments: dict):
            node_id = function_name_to_node_id.get(function_name, function_name)

            async def wrapper():
                send_flow_event(
                    flow_id=self.context.node_setup_version_id,
                    run_id=self.context.run_id,
                    node_id=node_id,
                    event_type='start_tool',
                )
                try:
                    result = function_call(**arguments)
                    if asyncio.iscoroutine(result):
                        result = await result
                    return result
                finally:
                    send_flow_event(
                        flow_id=self.context.node_setup_version_id,
                        run_id=self.context.run_id,
                        node_id=node_id,
                        event_type='end_tool',
                    )

            return await wrapper()

        self.instance = Agent(
            model=model,
            name=self.agent_name,
            agent_id=self.agent_id,
            user_id=self.user_id,
            introduction=dedent(self.introduction) if self.introduction else None,
            description=dedent(self.description) if self.description else None,
            instructions=dedent(self.instructions) if self.instructions else None,
            goal=self.goal,
            expected_output=dedent(self.expected_output) if self.expected_output else None,
            retries=self.retries,
            delay_between_retries=self.delay_between_retries,
            exponential_backoff=self.exponential_backoff,
            tools=tool_instances or None,
            debug_mode=self.debug_mode,
            debug_level=debug_level,
            monitoring=self.monitoring,
            telemetry=self.telemetry,
            tool_hooks=[tool_hook],
            events_to_skip=[],
            stream=True,
            **props
        )

    async def provide_instance(self) -> Agent:
        await self._create_agent()
        return self.instance

    async def execute(self):
        # if this is part of a team, or a sub for another agent
        # that team or agent will handle the execution
        if has_connected_agent_or_team(self):
            print('SKIPPED AGENT EXECUTION: connected agent or team found')
            return

        await self._create_agent()

        try:
            stream = await self.instance.arun(self.prompt, stream=True, stream_intermediate_steps=True)

            async def _collect_response(generator):
                final = None
                async for step in generator:
                    # print("STEP", step)
                    final = step
                return final

            response = await _collect_response(stream)

            self.true_path = response.content
            self.metrics = self.instance.run_response.metrics
        except Exception as e:
            self.false_path = NodeError.format(e, True)
            return
